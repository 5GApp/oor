module lispsimple {
  namespace "urn:ietf:params:xml:ns:yang:lispsimple";
  prefix lispsimple;

  import ietf-inet-types {
      prefix inet;
    }
    import ietf-yang-types {
      prefix yang;
    }
//    import ietf-interfaces {
//      prefix if;
//    }
    import iana-afn-safi {
      prefix iana;
    }
//    import lisp-address-types {
//      prefix lcaf;
//    }

    organization "IETF LISP (Locator/ID Separation Protocol) Working Group";
    contact
      "lisp@ietf.org";
    description
      "This YANG module defines the generic configuration
       data for LISP. The module can be extended by vendors 
       to define vendor-specific LISP configuration 
       parameters and policies.
       
       Copyright (c) 2015 IETF Trust and the persons identified as
       authors of the code.  All rights reserved.
       
       Redistribution and use in source and binary forms, with or
       without modification, is permitted pursuant to, and subject
       to the license terms contained in, the Simplified BSD License
       set forth in Section 4.c of the IETF Trust's Legal Provisions
       Relating to IETF Documents
       (http://trustee.ietf.org/license-info).
       
       This version of this YANG module is part of RFC 6338; see
       the RFC itself for full legal notices.
       
      ";

    revision 2015-02-11 {
      description
        "Initial revision.";
    }

    typedef negative-mapping-action {
      description
        "Defines the lisp map-cache ACT type";
      type enumeration {
        enum "no-action" {
          value 0;
        }
        enum "natively-forward" {
          value 1;
        }
        enum "send-map-request" {
          value 2;
        }
        enum "drop" {
          value 3;
        }
      }
    }

    //AR: Can be refined in the future (i.e. limit LCAF types)
    typedef eid-address {
      type union {
        type inet:ip-prefix;
        type yang:mac-address;
//        type lcaf:lisp-address;
      }
    }

    //AR: Can be refined in the future (i.e. limit LCAF types)
    typedef rloc-address {
      type union {
        type inet:ip-address;
//        type lcaf:lisp-address;
      }
    }

    typedef loc-space-address {
      type union {
        type inet:ip-address;
        //AR: YANG does not allow to use a leafref within an union
//        type if:interface-ref;
      }
    }

    typedef instance-id-type {
      type uint32 {
        range "0..16777214";
      }
    }




    grouping rlocs {
      list rloc {
        key "afi address";
        //AR: Here and in general in the model. Do we want to explicitly use an afi field? Can't we guess it from the address type?
        leaf afi { 
          type iana:address-family;
        }
        leaf address {
          type rloc-address;
        }
        leaf priority {
          type uint8;
        }
        leaf weight {
          type uint8;
        }
        leaf multicast-priority {
          type uint8;
        }
        leaf multicast-weight {
          type uint8;
        }
      }
    }

    grouping mappings {
      list mapping {
        key "instance-id eid-prefix";
        //AR: Here and in general in the model. Do we want to use an instance-id field? Shouldnâ€™t we embed it within lisp-address type?
        leaf instance-id {
          type instance-id-type;
        }
        leaf eid-prefix {
          type eid-address;
        }
        leaf ttl {
          type uint32;
        }
        choice locators {
          case negative-mapping {
            leaf negative-mapping-action {
              type negative-mapping-action;
            }
          }
          case positive-mapping {
            container rlocs {
              uses rlocs;
            }
          }
          default "positive-mapping";
        }
      }
    }

    
    container itr {
      presence "LISP ITR operation enabled";
      
      container rloc-probing {
        presence "RLOC probing active";
        leaf interval {
          type uint16;
          units "seconds";
          description
            "Interval in seconds";
        }
        leaf retries {
          type uint8;
          description
            "Number of retries";
        }
        leaf retries-interval {
          type uint16;
          units "seconds";
          description
            "Interval in seconds between retries";
        }
      }
      container itr-rlocs {
        description
          "List of RLOCs of the ITR included in Map-Requests";
        list itr-rloc {
          key "afi address";
          leaf afi {
            type iana:address-family;
          }
          leaf address {
            type loc-space-address;
          }
        }
      }
      container local-eid-database {
        list local-eid {
//          min-elements 1;
          key "instance-id eid-prefix";
          leaf instance-id {
            type instance-id-type;
          }
          leaf eid-prefix {
            type eid-address;
          }
          container local-rlocs{
              uses rlocs;
          }
        }
      }
      container map-resolvers {
        leaf-list map-resolver {
          type loc-space-address;
//          min-elements 1;
        }
      }
      container proxy-etrs {
        leaf-list proxy-etr {
          type loc-space-address;
        }
      }
      //AR: Do we want to separate configured entries from learned ones?
      container map-cache {
        uses mappings;
      }
    }
  
  
}
