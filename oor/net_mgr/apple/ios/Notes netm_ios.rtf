{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 NET_MGR\
\
\
int ios_netm_init();\

\f1\b0 \
no s'utilitza\

\f0\b \
void ios_netm_uninit();\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1\b0 \cf0 no s'utilitza
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 \
glist_t * ios_get_ifaces_names();\

\f1\b0 \
Funciona.\
Utiltizant ifaddr.\
Repasar log de errors.\
\

\f0\b glist_t * ios_get_iface_addr_list(char *iface_name, int afi);\

\f1\b0 \
Funciona.\
Exactament igual a krn_get_iface_addr_list\
\

\f0\b lisp_addr_t * ios_get_src_addr_to(lisp_addr_t *addr);\

\f1\b0 \
serveix per a saber quin src_addr posar en el paquet en cas de que la interficie tingui mes de una adre\'e7a IP assignada.\
\
No implementat de moment.\

\f0\b \
lisp_addr_t * ios_get_iface_gw(char *iface_name, int afi);\

\f1\b0 \
Funciona.\
Teoricament funciona, tot i que al recuperar el return desde el main i printar el lisp_addr_t no printa la IP correctament, pero tambe passa en la versio per Linux.
\f0\b \
\
uint8_t ios_get_iface_status(char *iface_name);\
\

\f1\b0 Funciona.\
Hi ha un loop que passa per totes les interficies fins que trova la que estem buscant. En macos/ios tenim el metode if_nametoindex pero no he torvat cpa metode que dona tun index ens retorni una interface en concret.
\f0\b \
\
int ios_get_iface_index(char *iface_name);\

\f1\b0 \
Funciona.\
Exactament igual que krn_get_iface_index
\f0\b \
\
void ios_get_iface_mac_addr(char *iface_name, uint8_t *mac);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1\b0 \cf0 no s'utilitza
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 \
char * ios_get_iface_name_associated_with_prefix(lisp_addr_t * pref);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1\b0 \cf0 no s'utilitza\

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 int ios_reload_routes(uint32_t table, int afi);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1\b0 \cf0 no s'utilitza\

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 shash_t * ios_build_addr_to_if_name_hasht();\
\

\f1\b0 Funciona.\
Exactament igual que krn_build_addr_to_if_name_hasht
\f0\b \
\
}