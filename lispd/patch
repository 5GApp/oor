diff --git a/lispd/lispd_config.c b/lispd/lispd_config.c
index 9143cb8..8df01ce 100644
--- a/lispd/lispd_config.c
+++ b/lispd/lispd_config.c
@@ -680,13 +680,13 @@ int add_database_mapping(
         iid = -1;
     }
 
-    if (priority_v4 < MAX_PRIORITY || priority_v4 > UNUSED_RLOC_PRIORITY) {
+    if (priority_v4 < (MAX_PRIORITY - 1) || priority_v4 > UNUSED_RLOC_PRIORITY) {
         lispd_log_msg(LISP_LOG_ERR, "Configuration file: Priority %d out of range [%d..%d], set minimum priority...",
                 priority_v4, MAX_PRIORITY, UNUSED_RLOC_PRIORITY);
         priority_v4 = MIN_PRIORITY;
     }
 
-    if (priority_v6 < MAX_PRIORITY || priority_v6 > UNUSED_RLOC_PRIORITY) {
+    if (priority_v6 < (MAX_PRIORITY - 1)|| priority_v6 > UNUSED_RLOC_PRIORITY) {
         lispd_log_msg(LISP_LOG_ERR, "Configuration file: Priority %d out of range [%d..%d], set minimum priority...",
                 priority_v6, MAX_PRIORITY, UNUSED_RLOC_PRIORITY);
         priority_v6 = MIN_PRIORITY;
@@ -730,7 +730,7 @@ int add_database_mapping(
         is_new_mapping = FALSE;
     }
     /*
-     * Add the new interface.
+     * Add the interface.
      */
     /* Check if the interface already exists. If not, add it*/
     if ((interface=get_interface(iface_name))==NULL){
@@ -748,8 +748,8 @@ int add_database_mapping(
         return (BAD);
     }
 
-    /* If interface has IPv4 address. Assign the mapping to the v4 mappings of the interface. Create IPv4 locator and assign to the mapping  */
-    if (interface->ipv4_address && priority_v4 >= 0){
+    /* Assign the mapping to the v4 mappings of the interface. Create IPv4 locator and assign to the mapping  */
+    if (priority_v4 >= 0){
         if ((err = add_mapping_to_interface (interface, mapping,AF_INET)) == GOOD){
 
             locator = new_local_locator (interface->ipv4_address,&(interface->status),priority_v4,weight_v4,255,0,interface->out_socket_v4);
@@ -765,7 +765,7 @@ int add_database_mapping(
             return (BAD);
         }
     }
-    /* If interface has IPv6 address. Assign the mapping to the v6 mappings of the interface. Create IPv6 locator and assign to the mapping  */
+    /* Assign the mapping to the v6 mappings of the interface. Create IPv6 locator and assign to the mapping  */
     if (interface->ipv6_address  && priority_v6 >= 0){
         if ((err = add_mapping_to_interface (interface, mapping,AF_INET6)) == GOOD){
             locator = new_local_locator (interface->ipv6_address,&(interface->status),priority_v6,weight_v6,255,0,interface->out_socket_v6);
diff --git a/lispd/lispd_iface_list.c b/lispd/lispd_iface_list.c
index f5c0c4e..0b9f149 100644
--- a/lispd/lispd_iface_list.c
+++ b/lispd/lispd_iface_list.c
@@ -59,34 +59,46 @@ lispd_iface_elt *add_interface(char *iface_name)
         free(iface_list);
         return(NULL);
     }
-    if ((iface->ipv4_address = malloc(sizeof(lisp_addr_t)))==NULL){
+    if ((iface->ipv4_address = (lisp_addr_t *)malloc(sizeof(lisp_addr_t)))==NULL){
     	lispd_log_msg(LISP_LOG_WARNING,"add_interface: Unable to allocate memory for lisp_addr_t: %s", strerror(errno));
     	free(iface_list);
     	free(iface);
     	return(NULL);
     }
-    if ((iface->ipv6_address = malloc(sizeof(lisp_addr_t)))==NULL){
+    if ((iface->ipv6_address = (lisp_addr_t *)malloc(sizeof(lisp_addr_t)))==NULL){
     	lispd_log_msg(LISP_LOG_WARNING,"add_interface: Unable to allocate memory for lisp_addr_t: %s", strerror(errno));
     	free(iface_list);
     	free(iface->ipv4_address);
     	free(iface);
     	return(NULL);
     }
+    memset(iface->ipv4_address,0,sizeof(lisp_addr_t));
+    memset(iface->ipv6_address,0,sizeof(lisp_addr_t));
+
     iface->iface_name = malloc(strlen(iface_name) + 1);   // XXX Must free elsewhere
     strcpy(iface->iface_name, iface_name);
-    iface->status = UP;
-    iface->ipv4_address = lispd_get_iface_address(iface_name, iface->ipv4_address, AF_INET);
-    if (iface->ipv4_address != NULL){
+
+    err = lispd_get_iface_address(iface_name, iface->ipv4_address, AF_INET);
+    if (err == GOOD){
         iface->out_socket_v4 = open_device_binded_raw_socket(iface->iface_name,AF_INET);
     }else {
+        iface->ipv4_address->afi = AF_UNSPEC;
         iface->out_socket_v4 = -1;
     }
-    iface->ipv6_address = lispd_get_iface_address(iface_name, iface->ipv6_address, AF_INET6);
-    if (iface->ipv6_address != NULL){
+    err = lispd_get_iface_address(iface_name, iface->ipv6_address, AF_INET6);
+    if (err == GOOD){
         iface->out_socket_v6 = open_device_binded_raw_socket(iface->iface_name,AF_INET6);
     }else {
+        iface->ipv6_address->afi = AF_UNSPEC;
         iface->out_socket_v6 = -1;
     }
+
+    if ( iface->ipv4_address->afi == AF_UNSPEC &&  iface->ipv6_address->afi == AF_UNSPEC){
+        iface->status = DOWN;
+    }else{
+        iface->status = UP;
+    }
+
     iface->head_v4_mappings_list = NULL;
     iface->head_v6_mappings_list = NULL;
     iface->status_transition_timer = NULL;
diff --git a/lispd/lispd_iface_mgmt.c b/lispd/lispd_iface_mgmt.c
index 0fb2fe9..d565dc2 100644
--- a/lispd/lispd_iface_mgmt.c
+++ b/lispd/lispd_iface_mgmt.c
@@ -33,14 +33,22 @@
 #include "lispd_log.h"
 #include "lispd_mapping.h"
 #include "lispd_smr.h"
+#include "lispd_sockets.h"
 #include "lispd_timers.h"
 
+/************************* FUNCTION DECLARTAION ********************************/
+
 void process_nl_add_address (struct nlmsghdr *nlh);
 void process_nl_del_address (struct nlmsghdr *nlh);
 void process_nl_new_link (struct nlmsghdr *nlh);
-int interface_change_update(
-    timer *timer,
-    void *arg);
+/*
+ * Activate the locators associated with the interface using the new address
+ * This function is only used when an interface is down during the initial configuration process and then is activated
+ */
+void activate_interface_address(lispd_iface_elt *iface,lisp_addr_t new_address);
+int interface_change_update(timer *timer, void *arg);
+
+/*******************************************************************************/
 
 int opent_netlink_socket()
 {
@@ -122,6 +130,7 @@ void process_nl_add_address (struct nlmsghdr *nlh)
     lisp_addr_t                 *iface_addr         = NULL;
     lispd_mappings_list         *mapping_list       = NULL;
     lcl_mapping_extended_info   *lcl_extended_info  = NULL;
+    int                         aux_afi             = 0;
 
     /*
      * Get the new address from the net link message
@@ -175,31 +184,35 @@ void process_nl_add_address (struct nlmsghdr *nlh)
         break;
     }
 
-    if (iface_addr == NULL){
-        /* XXX To be done */
-        lispd_log_msg(LISP_LOG_DEBUG_1,"process_nl_add_address: Automatic assignemen of locators is not supported."
-                "Restart LISPmob to use %s as a locator", get_char_from_lisp_addr_t(new_addr));
+    // Same address that we already have
+    if (compare_lisp_addr_t(iface_addr,&new_addr)==0){
+        lispd_log_msg(LISP_LOG_DEBUG_2,"process_nl_add_address: The detected change of address for interface %s "
+                "doesn't affect",iface->iface_name);
         return;
     }
 
-    if (compare_lisp_addr_t(iface_addr,&new_addr)==0){ // Same address that we already have
-        lispd_log_msg(LISP_LOG_DEBUG_2,"process_nl_add_address: The detected change of address for interface %s "
-                "doesn't affect",iface->iface_name);
+    aux_afi = iface_addr->afi;
+    // Update the new address
+    copy_lisp_addr(iface_addr, &new_addr);
+
+    // The interface was down during initial configuratiopn process and now it is up.
+    if (aux_afi == AF_UNSPEC){
+        lispd_log_msg(LISP_LOG_DEBUG_1,"process_nl_add_address: Activating the locator address %s"
+                , get_char_from_lisp_addr_t(new_addr));
+        activate_interface_address(iface, new_addr);
         return;
     }
 
     lispd_log_msg(LISP_LOG_DEBUG_2,"process_nl_add_address: New address detected for interface %s -> %s: Start SMR process",
                     iface->iface_name, get_char_from_lisp_addr_t(new_addr));
 
-    // Update the new address
-    copy_lisp_addr(iface_addr, &new_addr);
-
     /* Set the affected mappings as updated and sort again the locators list of the affected mappings*/
     while (mapping_list != NULL){
-        printf ("1******************************************************\n");
-        sort_locators_list_elt (mapping_list->mapping, iface_addr);
+        if (aux_afi != AF_UNSPEC){
+            sort_locators_list_elt (mapping_list->mapping, iface_addr);
+        }
         lcl_extended_info = (lcl_mapping_extended_info *)(mapping_list->mapping->extended_info);
-        lcl_extended_info->mapping_updated = TRUE;
+        lcl_extended_info->requires_smr = TRUE;
         mapping_list = mapping_list->next;
     }
 
@@ -297,11 +310,82 @@ void process_nl_new_link (struct nlmsghdr *nlh)
             (timer_callback)interface_change_update, (void *)arguments);
 }
 
+/*
+ * Activate the locators associated with the interface using the new address
+ * This function is only used when an interface is down during the initial configuration process and then is activated
+ */
+
+void activate_interface_address(
+        lispd_iface_elt     *iface,
+        lisp_addr_t         new_address)
+{
+    lispd_mappings_list     *mapping_list               = NULL;
+    lispd_mapping_elt       *mapping                    = NULL;
+    lispd_locators_list     *not_init_locators_list     = NULL;
+    lispd_locators_list     **locators_list             = NULL;
+    lispd_locator_elt       *locator                    = NULL;
+
+    switch(new_address.afi){
+    case AF_INET:
+        mapping_list = iface->head_v4_mappings_list;
+        iface->out_socket_v4 = open_device_binded_raw_socket(iface->iface_name,AF_INET);
+        break;
+    case AF_INET6:
+        mapping_list = iface->head_v6_mappings_list;
+        iface->out_socket_v6 = open_device_binded_raw_socket(iface->iface_name,AF_INET6);
+        break;
+    }
+
+    /*
+     * Activate the locator for each mapping associated with the interface
+     */
+    while (mapping_list != NULL){
+        printf("1-----------------------------------\n");
+        mapping = mapping_list->mapping;
+        dump_mapping_entry(mapping,LISP_LOG_DEBUG_1);
+        not_init_locators_list = ((lcl_mapping_extended_info *)mapping->extended_info)->head_not_init_locators_list;
+        locator = extract_locator_from_list (&not_init_locators_list, new_address);
+        if (locator != NULL){
+            printf("************* \n");
+            switch(new_address.afi){
+            case AF_INET:
+                ((lcl_locator_extended_info *)locator->extended_info)->out_socket = iface->out_socket_v4;
+                locators_list = &mapping->head_v4_locators_list;
+                break;
+            case AF_INET6:
+                ((lcl_locator_extended_info *)locator->extended_info)->out_socket = iface->out_socket_v6;
+                locators_list = &mapping->head_v6_locators_list;
+                break;
+            }
+            //printf("1==========> %s\n",get_char_from_lisp_addr_t(*(locators_list->locator->locator_addr)));
+            if (add_locator_to_list (locators_list,locator)!=GOOD){
+                printf("FREE LOCATOR\n\n");
+                free_locator(locator);
+            }else{
+                //printf("2==========> %s\n",get_char_from_lisp_addr_t(*(*locators_list->locator->locator_addr)));
+                dump_mapping_entry(mapping,LISP_LOG_DEBUG_1);
+                printf("2-----------------------------------\n");
+            }
+        }else{
+            lispd_log_msg(LISP_LOG_DEBUG_1,"activate_interface_address: No locator with address %s has been found"
+                    " in the not init locators list of the mapping %s/%d. It should never reach here",
+                    get_char_from_lisp_addr_t(new_address),
+                    get_char_from_lisp_addr_t(mapping->eid_prefix),
+                    mapping->eid_prefix_length);
+        }
+        dump_mapping_entry(mapping,LISP_LOG_DEBUG_1);
+        mapping_list = mapping_list->next;
+        printf("3-----------------------------------\n");
+
+    }
+}
+
+
+
 int interface_change_update(
     timer *timer,
     void *arg)
 {
-    printf ("===><==================================>\n");
     timer_iface_status_update_argument     *argument           = (timer_iface_status_update_argument *)arg;
     lispd_mappings_list                    *mapping_list[2]    = {NULL, NULL};
     lcl_mapping_extended_info              *lcl_extended_info  = NULL;
@@ -348,7 +432,7 @@ int interface_change_update(
     for (ctr = 0 ; ctr < 2 ; ctr ++){
         while (mapping_list[ctr] != NULL){
             lcl_extended_info = (lcl_mapping_extended_info *)(mapping_list[ctr]->mapping->extended_info);
-            lcl_extended_info->mapping_updated = TRUE; /* Change in the mapping */
+            lcl_extended_info->requires_smr = TRUE; /* Change in the mapping */
             calculate_balancing_vectors (
                     mapping_list[ctr]->mapping,
                     &(lcl_extended_info->outgoing_balancing_locators_vecs));
diff --git a/lispd/lispd_lib.c b/lispd/lispd_lib.c
index 32ea681..66546e2 100644
--- a/lispd/lispd_lib.c
+++ b/lispd/lispd_lib.c
@@ -254,10 +254,11 @@ int lispd_get_address(
 /*
  *  lispd_get_iface_address
  *
- *  return lisp_addr_t for the interface, 0 if none
+ *  fill the parameter addr with the lisp_addr_t of the interface with afi.
+ *  Return BAD if no address is present in the interface.
  */
 
-lisp_addr_t *lispd_get_iface_address(
+int lispd_get_iface_address(
     char                *ifacename,
     lisp_addr_t         *addr,
     int                 afi)
@@ -274,7 +275,7 @@ lisp_addr_t *lispd_get_iface_address(
         if(afi != default_rloc_afi){
             lispd_log_msg(LISP_LOG_INFO,"Default RLOC afi defined: Skipped %s address in iface %s",
                           (afi == AF_INET) ? "IPv4" : "IPv6",ifacename);
-            return (NULL);
+            return (BAD);
         }
     }
 
@@ -291,7 +292,7 @@ lisp_addr_t *lispd_get_iface_address(
     if (getifaddrs(&ifaddr) !=0) {
         lispd_log_msg(LISP_LOG_DEBUG_2,
                "lispd_get_iface_address: getifaddrs error: %s", strerror(errno));
-        return(NULL);
+        return(BAD);
     }
 
     for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
@@ -317,7 +318,7 @@ lisp_addr_t *lispd_get_iface_address(
                         inet_ntop(AF_INET, &(s4->sin_addr), 
                             addr_str, MAX_INET_ADDRSTRLEN));
                 freeifaddrs(ifaddr);
-                return(addr);
+                return(GOOD);
             } else {
                 continue;
             }
@@ -341,7 +342,7 @@ lisp_addr_t *lispd_get_iface_address(
                         inet_ntop(AF_INET6, &(s6->sin6_addr), 
                             addr_str, MAX_INET_ADDRSTRLEN));
                 freeifaddrs(ifaddr);
-                return(addr);
+                return(GOOD);
             } else {
                 continue;
             }
@@ -353,7 +354,7 @@ lisp_addr_t *lispd_get_iface_address(
     lispd_log_msg(LISP_LOG_DEBUG_3, "lispd_get_iface_address: No %s RLOC configured for interface %s\n",
             (afi == AF_INET) ? "IPv4" : "IPv6",
             ifacename);
-    return(NULL);
+    return(BAD);
 }
 
 /*
diff --git a/lispd/lispd_lib.h b/lispd/lispd_lib.h
index 692a60f..82d85bf 100644
--- a/lispd/lispd_lib.h
+++ b/lispd/lispd_lib.h
@@ -76,9 +76,10 @@ int copy_addr(void *a1, lisp_addr_t *a2, int convert);
 int lispd_get_address(char *host, lisp_addr_t *addr);
 
 /*
- *  return lisp_addr_t for the interface, 0 if none
+ *  Fill the parameter addr with the lisp_addr_t of the interface with afi.
+ *  Return BAD if no address is present in the interface.
  */
-lisp_addr_t *lispd_get_iface_address(char *ifacename, lisp_addr_t *addr, int afi);
+int lispd_get_iface_address(char *ifacename, lisp_addr_t *addr, int afi);
 
 
 void dump_servers(lispd_addr_list_t *list, const char *list_name, int log_level);
diff --git a/lispd/lispd_locator.c b/lispd/lispd_locator.c
index ec3ebd9..955a1ac 100644
--- a/lispd/lispd_locator.c
+++ b/lispd/lispd_locator.c
@@ -287,7 +287,8 @@ int add_locator_to_list (
 
     locator_list->next = NULL;
     locator_list->locator = locator;
-    if (locator->locator_type == LOCAL_LOCATOR){/* If it's a local locator, we should store it in order*/
+    if (locator->locator_type == LOCAL_LOCATOR &&
+            locator->locator_addr->afi != AF_UNSPEC){ /* If it's a local initialized locator, we should store it in order*/
         if (*list == NULL){
             *list = locator_list;
         }else{
@@ -319,7 +320,7 @@ int add_locator_to_list (
                 locator_list->next = aux_locator_list_next;
             }
         }
-    }else{
+    }else{ /* Remote locators and not initialized local locators */
         if (*list == NULL){
             *list = locator_list;
         }else{
@@ -334,7 +335,37 @@ int add_locator_to_list (
     return (GOOD);
 }
 
-
+/*
+ * Extract the locator from a locators list that match with the address.
+ * The locator is removed from the list
+ */
+lispd_locator_elt *extract_locator_from_list(
+        lispd_locators_list     **head_locator_list,
+        lisp_addr_t             addr)
+{
+    lispd_locator_elt       *locator                = NULL;
+    lispd_locators_list     *locator_list           = NULL;
+    lispd_locators_list     *prev_locator_list_elt  = NULL;
+
+    locator_list = *head_locator_list;
+    while (locator_list != NULL){
+       if (locator_list->locator->locator_addr->afi != AF_UNSPEC &&
+                compare_lisp_addr_t(locator_list->locator->locator_addr,&addr)==0){
+            locator = locator_list->locator;
+            /* Extract the locator from the list */
+            if (prev_locator_list_elt != NULL){
+                prev_locator_list_elt->next = locator_list->next;
+            }else{
+                *head_locator_list = locator_list->next;
+            }
+            free (locator_list);
+            break;
+        }
+        prev_locator_list_elt = locator_list;
+        locator_list = locator_list->next;
+    }
+    return (locator);
+}
 
 /*
  * Free memory of lispd_locator_list.
diff --git a/lispd/lispd_locator.h b/lispd/lispd_locator.h
index 8d1d6f0..bfc3b6f 100644
--- a/lispd/lispd_locator.h
+++ b/lispd/lispd_locator.h
@@ -128,6 +128,14 @@ int add_locator_to_list (
         lispd_locators_list         **list,
         lispd_locator_elt           *locator);
 
+/*
+ * Extract the locator from a locators list that match with the address.
+ * The locator is removed from the list
+ */
+lispd_locator_elt *extract_locator_from_list(
+        lispd_locators_list     **head_locator_list,
+        lisp_addr_t             addr);
+
 
 /*
  * Free memory of lispd_locator_list.
diff --git a/lispd/lispd_map_cache.h b/lispd/lispd_map_cache.h
index 2c9fa2a..db4ce51 100644
--- a/lispd/lispd_map_cache.h
+++ b/lispd/lispd_map_cache.h
@@ -62,8 +62,6 @@ typedef struct lispd_map_cache_entry_ {
     uint8_t                     active_witin_period:1;
     uint8_t                     probe_left;     /* Counter to indicate number of RLOCs that has not been probed /put status down
                                                  * in this period of probe*/
-    uint8_t                     smr_inv_left;   /* Counter to indicate number of replies to the smr invoques  has not been recived  /put status down
-                                                 * in this period of probe*/
     uint16_t                    ttl;
     time_t                      timestamp;
     timer                       *expiry_cache_timer;
diff --git a/lispd/lispd_mapping.c b/lispd/lispd_mapping.c
index e8b5ee9..14e033d 100644
--- a/lispd/lispd_mapping.c
+++ b/lispd/lispd_mapping.c
@@ -131,7 +131,7 @@ lispd_mapping_elt *new_local_mapping(
     extended_info->outgoing_balancing_locators_vecs.v6_locators_vec_length = 0;
     extended_info->outgoing_balancing_locators_vecs.locators_vec_length = 0;
 
-    extended_info->mapping_updated = FALSE;
+    extended_info->requires_smr = FALSE;
 
     return (mapping);
 }
@@ -177,28 +177,45 @@ int add_locator_to_mapping(
         lispd_mapping_elt           *mapping,
         lispd_locator_elt           *locator)
 {
-    if (locator->locator_addr->afi == AF_INET){
+    int result = GOOD;
+
+    switch (locator->locator_addr->afi){
+    case AF_INET:
         err = add_locator_to_list (&(mapping->head_v4_locators_list), locator);
-    }else {
+        break;
+    case AF_INET6:
         err = add_locator_to_list (&(mapping->head_v6_locators_list), locator);
+        break;
+    case AF_UNSPEC:
+        err = add_locator_to_list (&(((lcl_mapping_extended_info *)(mapping->extended_info))->head_not_init_locators_list), locator);
+        if (err == GOOD){
+            return (GOOD);
+        }else{
+            free_locator (locator);
+            return (BAD);
+        }
     }
+
     if (err == GOOD){
         mapping->locator_count++;
         lispd_log_msg(LISP_LOG_DEBUG_2, "add_locator_to_mapping: The locator %s has been added to the EID %s/%d.",
                 get_char_from_lisp_addr_t(*(locator->locator_addr)),
                 get_char_from_lisp_addr_t(mapping->eid_prefix),
                 mapping->eid_prefix_length);
-        return (GOOD);
+        result = GOOD;
     }else if (err == ERR_EXIST){
         free_locator (locator);
         lispd_log_msg(LISP_LOG_DEBUG_2, "add_locator_to_mapping: The locator %s already exists for the EID %s/%d.",
                 get_char_from_lisp_addr_t(*(locator->locator_addr)),
                 get_char_from_lisp_addr_t(mapping->eid_prefix),
                 mapping->eid_prefix_length);
-        return (GOOD);
+        result = GOOD;
+    }else{
+        free_locator (locator);
+        result = BAD;
     }
-    free_locator (locator);
-    return (BAD);
+
+    return (result);
 }
 
 
@@ -310,6 +327,7 @@ void free_mapping_elt(lispd_mapping_elt *mapping, int local)
     free_locator_list(mapping->head_v6_locators_list);
     /* Free extended info */
     if (local == TRUE){
+        free_locator_list(((lcl_mapping_extended_info *)mapping->extended_info)->head_not_init_locators_list);
         free_balancing_locators_vecs(((lcl_mapping_extended_info *)mapping->extended_info)->outgoing_balancing_locators_vecs);
         free ((lcl_mapping_extended_info *)mapping->extended_info);
     }else{
diff --git a/lispd/lispd_mapping.h b/lispd/lispd_mapping.h
index c4502f2..5f71fe9 100644
--- a/lispd/lispd_mapping.h
+++ b/lispd/lispd_mapping.h
@@ -75,7 +75,8 @@ typedef struct balancing_locators_vecs_ {
 
 typedef struct lcl_mapping_extended_info_ {
     balancing_locators_vecs               outgoing_balancing_locators_vecs;
-    uint8_t                               mapping_updated:1; //when an interface related to this mapping change, it is set to TRUE
+    uint8_t                               requires_smr:1; //when an interface related to this mapping change, it is set to TRUE
+    lispd_locators_list                   *head_not_init_locators_list; //List of locators not initialized: interface without ip
 }lcl_mapping_extended_info;
 
 /*
diff --git a/lispd/lispd_pkt_lib.c b/lispd/lispd_pkt_lib.c
index 6f1d75e..9ee630b 100644
--- a/lispd/lispd_pkt_lib.c
+++ b/lispd/lispd_pkt_lib.c
@@ -244,7 +244,7 @@ void *pkt_fill_mapping_record(
     locators_list[1] = mapping->head_v6_locators_list;
     for (ctr = 0 ; ctr < 2 ; ctr++){
         while (locators_list[ctr]) {
-            locator             = locators_list[ctr]->locator;
+            locator              = locators_list[ctr]->locator;
             loc_ptr->priority    = locator->priority;
             loc_ptr->weight      = locator->weight;
             loc_ptr->mpriority   = locator->mpriority;
diff --git a/lispd/lispd_smr.c b/lispd/lispd_smr.c
index fa87492..06ea70f 100644
--- a/lispd/lispd_smr.c
+++ b/lispd/lispd_smr.c
@@ -68,7 +68,7 @@ void init_smr()
         PATRICIA_WALK(local_dbs[ctr]->head, lcl_node) {
             mapping = ((lispd_mapping_elt *)(lcl_node->data));
             lcl_extended_info = (lcl_mapping_extended_info *)mapping->extended_info;
-            if (lcl_extended_info->mapping_updated == TRUE){
+            if (lcl_extended_info->requires_smr == TRUE){
                 /* Send a map register for the affected mapping */
                 build_and_send_map_register_msg(mapping);
 
@@ -97,7 +97,7 @@ void init_smr()
                     }
                 }PATRICIA_WALK_END;
 
-                lcl_extended_info->mapping_updated = FALSE;
+                lcl_extended_info->requires_smr = FALSE;
             }
 
         }PATRICIA_WALK_END;
